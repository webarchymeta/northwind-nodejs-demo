/* ------------------------------------------------------------------------------
 *
 *     This code was generated by CGW X-Script Code Generator.
 *
 *     Archymeta Information Technologies Co., Ltd.
 *
 *     Changes to this file, especially those bit flags, may cause incorrect behavior and will be lost if
 *     the code is regenerated.
 * 
 ------------------------------------------------------------------------------ */

var root = process.cwd(), 
    apppath = typeof global.appPath === 'undefined' || global.appPath === '' ? '' : 'config/' + global.appPath + '/',
    path = require('path'),
    edge = require(path.join(root, 'node_modules/edge')),
    B = require(path.join(root, 'node_modules/bluebird')),
    propFilters = require(path.join(root, '../services/adapters/proxies/Northwind/api/property-filters')),
    config = require(path.join(root, apppath + 'config')),
    appcontext = require(path.join(root, apppath + 'app-context'));

var api = function () {
    var self = this;
    var cntx = global.NorthwindClientContext;

    /**
     * <summary>
     *   Retrieve information about the entity set: "Order Details". 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="filter">Filter expression for the current set.</param>
     * <returns>
     *   Entity set: <see cref="Order_DetailSet" /> data model.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=GetSetInfo"
}
*/
    self.GetSetInfo = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                filter: input.filter
            };
            self._GetSetInfo(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Add or update a set of entities to the entity set. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">The current entity set.</param>
     * <param name="entities">The list of entities to be processed.</param>
     * <remarks>
     *  <para>
     *  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
     *  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
     *  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
     *  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
     *  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
     *  <para>
     *  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
     *  </para>
     *  <para>
     *  Note 2: A persisted entity (namely the one loaded
     *  from the data set) will be ignored in if none of its editable properties (set before system generation, see
     *  <see cref="Order_Detail" />) is modified or its <see cref="Order_Detail.IsEntityChanged" /> property is
     *  not set to <c>true</c>. 
     *  </para>
     *  <para>
     *  Clients can set some of the member entities in { <see cref="Order_Detail.OrderRef" />, <see cref="Order_Detail.ProductRef" /> } that an currently added or updated entity depends upon. These additional entities will be 
     *  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
     *  </para>
     *  <para>
     *  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
     *  </para>
     * </remarks>
     * <returns>
     *   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=AddOrUpdateEntities"
}
*/
    self.AddOrUpdateEntities = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                set: JSON.stringify(input.set),
                entities: JSON.stringify(input.entities)
            };
            self._AddOrUpdateEntities(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Queue a set of entities to be added or updated to the entity set in a certain preset future time. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">The current entity set.</param>
     * <param name="entities">The list of entities to be processed.</param>
     * <remarks>
     *  <para>
     *  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
     *  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
     *  interest to the client, namely only the last snapshot of the changes are relevant. In this case, the method can reduce the loads on the backend data source 
     *  significantly.
     *  </para>
     *  <para>
     *  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
     *  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
     *  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
     *  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
     *  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
     *  </para>
     *  <para>
     *  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
     *  </para>
     *  <para>
     *  Note 2: A persisted entity (namely the one loaded
     *  from the data set) will be ignored in if none of its editable properties (set before system generation, see
     *  <see cref="Order_Detail" />) is modified or its <see cref="Order_Detail.IsEntityChanged" /> property is
     *  not set to <c>true</c>. 
     *  </para>
     *  <para>
     *  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
     *  proceeding to the next steps.
     *  </para>
     * </remarks>
     * <returns>
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=EnqueueNewOrUpdateEntities"
}
*/
    self.EnqueueNewOrUpdateEntities = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                set: JSON.stringify(input.set),
                entities: JSON.stringify(input.entities)
            };
            self._EnqueueNewOrUpdateEntities(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  Delete a set of entities from the entity set, together with all their dependents, recursively. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">The current entity set.</param>
     * <param name="entities">The list of entities to be processed.</param>
     * <remarks>
     *  <para>
     *   Care should be taken when deleting an entire inter-dependent object sub-graph.
     *  </para>
     * </remarks>
     * <returns>
     *   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=DeleteEntities"
}
*/
    self.DeleteEntities = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                set: JSON.stringify(input.set),
                entities: JSON.stringify(input.entities)
            };
            self._DeleteEntities(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Get a block of page frames from the entity set "Order Details" of the data source under specified filtering and sorting conditions. 
     * </summary>
     * <remarks>
     * The page size and the page block size is specified inside "set".
     * </remarks>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
     * <returns>
     *   <see cref="Order_DetailPageBlock" /> data model for entity set "Order Details".
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=NextPageBlock"
}
*/

    self.NextPageBlock = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                set: JSON.stringify(input.set),
                qexpr: JSON.stringify(input.qexpr),
                prevlast: JSON.stringify(input.prevlast)
            };
            self._NextPageBlock(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Load entities of a page from the entity set "Order Details" of the data source under specified filtering and sorting conditions. 
     * </summary>
     * <remarks>
     * The page size is specified inside "set".
     * </remarks>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
     * <returns>
     *   Collection of <see cref="Order_Detail" /> in set "Order Details" for the current page defined by "prevlast".
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=GetPageItems"
}
*/
    self.GetPageItems = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                set: JSON.stringify(input.set),
                qexpr: JSON.stringify(input.qexpr),
                prevlast: JSON.stringify(input.prevlast)
            };
            self._GetPageItems(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    var cntx = JSON.parse(opts.cntx);
                    if ((typeof cntx.allProperties === 'undefined' || !cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Order_Detail'] !== 'undefined')
                        resolve(propFilters['Order_Detail'].many(returnObj, false));
                    else
                        resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Count the number of entities inside entity set "Order Details" of the data source under specified filtering condition. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <returns>
     *   The number of entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=QueryEntityCount"
}
*/

    self.QueryEntityCount = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                set: JSON.stringify(input.set),
                qexpr: JSON.stringify(input.qexpr)
            };
            self._QueryEntityCount(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Get the collection of entities of type <see cref="Order_Detail" /> inside entity set "Order Details" of the data source under specified filtering and sorting conditions. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <returns>
     *   The collection of entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=QueryDatabase"
}
*/
    self.QueryDatabase = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                set: JSON.stringify(input.set),
                qexpr: JSON.stringify(input.qexpr)
            };
            self._QueryDatabase(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    var cntx = JSON.parse(opts.cntx);
                    if ((typeof cntx.allProperties === 'undefined' || !cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Order_Detail'] !== 'undefined')
                        resolve(propFilters['Order_Detail'].many(returnObj, false));
                    else
                        resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Get the collection of entities of type <see cref="Order_Detail" /> inside entity set "Order Details" from the data source under specified filtering, sorting and max number of returning entities conditions. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <param name="maxRecords">Max number of entities to return.</param>
     * <returns>
     *   The collection of entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=QueryDatabaseLimited"
}
*/
    self.QueryDatabaseLimited = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                set: JSON.stringify(input.set),
                qexpr: JSON.stringify(input.qexpr),
                maxRecords: input.maxRecords
            };
            self._QueryDatabaseLimited(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    var cntx = JSON.parse(opts.cntx);
                    if ((typeof cntx.allProperties === 'undefined' || !cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Order_Detail'] !== 'undefined')
                        resolve(propFilters['Order_Detail'].many(returnObj, false));
                    else
                        resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Get the number of entities from the data source restricted by a set of specified foreign key values and under specified filtering, sorting conditions. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
    /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "Order Details" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <returns>
     *   The number of entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=ConstraintQueryEntityCount"
}
*/
    self.ConstraintQueryEntityCount = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                set: JSON.stringify(input.set),
                constraints: JSON.stringify(input.constraints),
                qexpr: JSON.stringify(input.qexpr)
            };
            self._ConstraintQueryEntityCount(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Given a set of foreign key constraints, find the ones that has non zero corresponding entities. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
    /// <param name="cnstSets">A collection of sets of foreign key wrapper pointing to primary keys of the sets that "Order Details" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <returns>
     *   A set of constraint pointer that has non-zero corresponding entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=ConstraintsFindMatches"
}
*/
    self.ConstraintsFindMatches = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                set: JSON.stringify(input.set),
                cnstSets: JSON.stringify(input.cnstSets),
                qexpr: JSON.stringify(input.qexpr)
            };
            self._ConstraintsFindMatches(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Get the collection of entities of type <see cref="Order_Detail" /> inside entity set "Order Details" from the data source restricted by a set of specified foreign key values and under specified filtering, sorting conditions. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
    /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "Order Details" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <returns>
     *   The collection of entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=ConstraintQuery"
}
*/
    self.ConstraintQuery = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                set: JSON.stringify(input.set),
                constraints: JSON.stringify(input.constraints),
                qexpr: JSON.stringify(input.qexpr)
            };
            self._ConstraintQuery(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    var cntx = JSON.parse(opts.cntx);
                    if ((typeof cntx.allProperties === 'undefined' || !cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Order_Detail'] !== 'undefined')
                        resolve(propFilters['Order_Detail'].many(returnObj, false));
                    else
                        resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Get the collection of entities of type <see cref="Order_Detail" /> inside entity set "Order Details" of the data source restricted by a set of specified foreign key values and under specified filtering, sorting and max number of returning entities conditions. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
    /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "Order Details" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <param name="maxRecords">Max number of entities to return.</param>
     * <returns>
     *   The collection of entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=ConstraintQueryLimited"
}
*/
    self.ConstraintQueryLimited = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                set: JSON.stringify(input.set),
                constraints: JSON.stringify(input.constraints),
                qexpr: JSON.stringify(input.qexpr),
                maxRecords: input.maxRecords
            };
            self._ConstraintQueryLimited(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    var cntx = JSON.parse(opts.cntx);
                    if ((typeof cntx.allProperties === 'undefined' || !cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Order_Detail'] !== 'undefined')
                        resolve(propFilters['Order_Detail'].many(returnObj, false));
                    else
                        resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Load the entity "OrderRef" of type <see cref="Order" /> that the entity depend upon. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="entity">The entity.</param>
     * <remarks>
     * If the corresponding foreign key is nullable, the returned entity can be null.
     * </remarks>
     * <returns>
     *   An entity of type <see cref="Order" /> or null.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=MaterializeOrderRef"
}
*/
    self.MaterializeOrderRef = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                entity: JSON.stringify(input.entity)
            };
            self._MaterializeOrderRef(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    var cntx = JSON.parse(opts.cntx);
                    if ((typeof cntx.allProperties === 'undefined' || !cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Order'] !== 'undefined')
                        resolve(propFilters['Order'].one(returnObj, false));
                    else
                        resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Load the entity "ProductRef" of type <see cref="Product" /> that the entity depend upon. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="entity">The entity.</param>
     * <remarks>
     * If the corresponding foreign key is nullable, the returned entity can be null.
     * </remarks>
     * <returns>
     *   An entity of type <see cref="Product" /> or null.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=MaterializeProductRef"
}
*/
    self.MaterializeProductRef = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                entity: JSON.stringify(input.entity)
            };
            self._MaterializeProductRef(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    var cntx = JSON.parse(opts.cntx);
                    if ((typeof cntx.allProperties === 'undefined' || !cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Product'] !== 'undefined')
                        resolve(propFilters['Product'].one(returnObj, false));
                    else
                        resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Get the collection of non-trivial foreign key constrains of type <see cref="Order_Detail" /> inside entity set "Order Details" of the data source under specified filtering and sorting conditions. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
     * <param name="qexpr">Filter expression for the set.</param>
     * <param name="max">Number of items per page.</param>
     * <param name="nextId">The id of next page, if any.</param>
     * <returns>
     *   The collection of independent non-trivial foreign key constrains.
     * </returns>
     * <remarks>It will throw an exception if the <see cref="Order_DetailSet.SetFilter" /> of <paramref name="set" /> is null or empty.</remarks>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=QuerySetConstraints"
}
*/
    self.QuerySetConstraints = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                set: JSON.stringify(input.set),
                qexpr: JSON.stringify(input.qexpr),
                max: input.max,
                nextId: input.nextId
            };
            self._QuerySetConstraints(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  Load an entity from the entity set having specified primary key(s): { <see cref="Order_Detail.OrderID" />, <see cref="Order_Detail.ProductID" /> }. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
    /// <param name="_OrderID">Primary key <see cref="Order_Detail.OrderID" />.</param>
    /// <param name="_ProductID">Primary key <see cref="Order_Detail.ProductID" />.</param>
     * <returns>
     *   Null or the entity found.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=LoadEntityByKey"
}
*/
    self.LoadEntityByKey = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                _OrderID: input._OrderID || input.OrderID,
                _ProductID: input._ProductID || input.ProductID
            };
            self._LoadEntityByKey(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    var cntx = JSON.parse(opts.cntx);
                    if ((typeof cntx.allProperties === 'undefined' || !cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Order_Detail'] !== 'undefined')
                        resolve(propFilters['Order_Detail'].one(returnObj, false));
                    else
                        resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="Order_Detail.OrderID" />, <see cref="Order_Detail.ProductID" /> }. . It is designed to be called by clients other than .Net native ones.
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
    /// <param name="_OrderID">Primary key <see cref="Order_Detail.OrderID" />.</param>
    /// <param name="_ProductID">Primary key <see cref="Order_Detail.ProductID" />.</param>
     * <param name="excludedSets">A list of sets to be excluded. </param>
     * <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
     * <remarks>
     * <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
     * However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
     * world and at the data view model level, these views can be represented using entity graphs.</para>
     * <para>This method is designed to load a selected sub entity graph recursively from the data source in one call to the service starting with a given entity (id).
     * It could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
     * <para>The selection is controlled by two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
     * <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
     * better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
     * if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
     * following other routes. </para>
     * <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
     * the entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also loads all 
     * elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
     * the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
     * <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
     * and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
     * <para>Note that a data service has intrinsic limits that do not allow transmitting an entity graph that is too large in one call, so one has to select which part
     * of the entire graph should be loaded in each call to the data service,</para>
     * <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
     * sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
     * these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
     * added after the graph is materialized on the clients side, if needed.</para>
     * </remarks>
     * <returns>
     *   Null or the entity graph found.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=LoadEntityGraphRecursJson"
}
*/
    self.LoadEntityGraphRecursJson = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                _OrderID: input._OrderID || input.OrderID,
                _ProductID: input._ProductID || input.ProductID,
                excludedSets: JSON.stringify(input.excludedSets),
                futherDrillSets: JSON.stringify(input.futherDrillSets)
            };
            self._LoadEntityGraphRecursJson(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  Load a set entities from the entity set having specified intrinsic ids: { <see cref="Order_Detail.OrderID" />, <see cref="Order_Detail.ProductID" /> }. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
    /// <param name="_OrderID">Intrinsic id <see cref="Order_Detail.OrderID" />.</param>
    /// <param name="_ProductID">Intrinsic id <see cref="Order_Detail.ProductID" />.</param>
     * <remarks>
     *  <para>
     *   The returned entity set should contain zero or one item or null.
     *  </para>
     * </remarks>
     * <returns>
     *   Null or zero or one entity.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=LoadEntityByNature"
}
*/
    self.LoadEntityByNature = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                    _OrderID: input._OrderID || input.OrderID, 
                    _ProductID: input._ProductID || input.ProductID
            };
            self._LoadEntityByNature(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    var cntx = JSON.parse(opts.cntx);
                    if ((typeof cntx.allProperties === 'undefined' || !cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Order_Detail'] !== 'undefined')
                        resolve(propFilters['Order_Detail'].many(returnObj, false));
                    else
                        resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="sorters">Sorter expression tokens.</param>
     * <returns>
     *   A list of possible sort tokens.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=GetNextSorterOps"
}
*/
    self.GetNextSorterOps = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                sorters: JSON.stringify(input.sorters)
            };
            self._GetNextSorterOps(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="qexpr">The current query expression.</param>
     * <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
     * <returns>
     *   A list of possible filter tokens.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/Order_DetailServiceInputParams?db=Northwind&subdoc=GetNextFilterOps"
}
*/
    self.GetNextFilterOps = function (input) {
        var __promise = new B(function (resolve, reject) {
            var opts = {
                cntx: JSON.stringify(config.mapCntx(input.cntx || cntx)),
                qexpr: JSON.stringify(input.qexpr),
                tkstr: input.tkstr
            };
            self._GetNextFilterOps(opts, function (error, result) {
                if (!error) {
                    var returnObj;
                    try {
                        returnObj = JSON.parse(result);
                    } catch (ex) {
                        var c = result.charCodeAt(result.length - 1);
                        if (c === 1) { // in the rare case that the SOH character is not stripped.
                            result = result.substr(0, result.length - 1);
                            returnObj = JSON.parse(result);
                        } else {
                            reject('failed!!!');
                            return;
                        }
                    }
                    resolve(returnObj);
                } else {
                    reject(error);
                }
            });
        });
        return __promise;
    };
};

var assemblyPath = path.join(global.NorthwindServerPath, 'NorthwindServiceAPI.NodeJS.dll');

api.prototype._GetSetInfo = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'GetSetInfo'
});

api.prototype._AddOrUpdateEntities = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'AddOrUpdateEntities'
});

api.prototype._EnqueueNewOrUpdateEntities = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'EnqueueNewOrUpdateEntities'
});

api.prototype._DeleteEntities = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'DeleteEntities'
});

api.prototype._NextPageBlock = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'NextPageBlock'
});

api.prototype._GetPageItems = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'GetPageItems'
});

api.prototype._QueryEntityCount = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'QueryEntityCount'
});

api.prototype._QueryDatabase = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'QueryDatabase'
});

api.prototype._QueryDatabaseLimited = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'QueryDatabaseLimited'
});

api.prototype._ConstraintQueryEntityCount = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'ConstraintQueryEntityCount'
});

api.prototype._ConstraintsFindMatches = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'ConstraintsFindMatches'
});

api.prototype._ConstraintQuery = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'ConstraintQuery'
});

api.prototype._ConstraintQueryLimited = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'ConstraintQueryLimited'
});

api.prototype._MaterializeOrderRef = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'MaterializeOrderRef'
});

api.prototype._MaterializeProductRef = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'MaterializeProductRef'
});

api.prototype._QuerySetConstraints = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'QuerySetConstraints'
});

api.prototype._LoadEntityByKey = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'LoadEntityByKey'
});

api.prototype._LoadEntityGraphRecursJson = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'LoadEntityGraphRecursJson'
});

api.prototype._LoadEntityByNature = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'LoadEntityByNature'
});

api.prototype._GetNextSorterOps = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'GetNextSorterOps'
});

api.prototype._GetNextFilterOps = edge.func({
    assemblyFile: assemblyPath,
    typeName: 'CryptoGateway.RDB.Data.Northwind.Order_DetailNodeJsApi',
    methodName: 'GetNextFilterOps'
});

module.exports = api;
