/* ------------------------------------------------------------------------------
 *
 *     This code was generated by CGW X-Script Code Generator.
 *
 *     Archymeta Information Technologies Co., Ltd.
 *
 *     Changes to this file, especially those bit flags, may cause incorrect behavior and will be lost if
 *     the code is regenerated.
 * 
 ------------------------------------------------------------------------------ */

var root = process.cwd(), 
    apppath = typeof global.appPath === 'undefined' || global.appPath === '' ? '' : 'config/' + global.appPath + '/',
    path = require('path'),
    req = require(path.join(root, 'node_modules/request')),
    Q = require(path.join(root, 'node_modules/q')),
    propFilters = require('../property-filters'),
    config = require(path.join(root, apppath + 'config'));

var api = function () {
    var self = this;
    var cntx = global.NorthwindClientContext;
    self.baseUrl = config.NorthwindServiceBaseUrl + '/Services/DataService/Northwind/EmployeeSet.svc';

    /**
     * <summary>
     *   Retrieve information about the entity set: "Employees". 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="filter">Filter expression for the current set.</param>
     * <returns>
     *   Entity set: <see cref="EmployeeSet" /> data model.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=GetSetInfo"
}
*/
    self.GetSetInfo = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/GetSetInfo',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx, 
                    filter: input.filter
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.GetSetInfoResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Add or update a set of entities to the entity set. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">The current entity set.</param>
     * <param name="entities">The list of entities to be processed.</param>
     * <remarks>
     *  <para>
     *  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
     *  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
     *  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
     *  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
     *  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
     *  <para>
     *  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
     *  </para>
     *  <para>
     *  Note 2: A persisted entity (namely the one loaded
     *  from the data set) will be ignored in if none of its editable properties (set before system generation, see
     *  <see cref="Employee" />) is modified or its <see cref="Employee.IsEntityChanged" /> property is
     *  not set to <c>true</c>. 
     *  </para>
     *  <para>
     *  Clients can set some of the member entities in { <see cref="Employee.UpperRef" /> } that an currently added or updated entity depends upon. These additional entities will be 
     *  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
     *  </para>
     *  <para>
     *  Clients can also create and add to member collections in { <see cref="Employee.ChangedEmployees" />, <see cref="Employee.ChangedEmployeeTerritorys" />, <see cref="Employee.ChangedOrders" /> } entities that depends on an currently added or updated entity. These 
     *  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
     *  </para>
     *  <para>
     *  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
     *  </para>
     * </remarks>
     * <returns>
     *   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=AddOrUpdateEntities"
}
*/
    self.AddOrUpdateEntities = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/AddOrUpdateEntities',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx, 
                    set: input.set, 
                    entities: input.entities
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.AddOrUpdateEntitiesResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Queue a set of entities to be added or updated to the entity set in a certain preset future time. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">The current entity set.</param>
     * <param name="entities">The list of entities to be processed.</param>
     * <remarks>
     *  <para>
     *  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
     *  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
     *  interest to the client, namely only the last snapshot of the changes are relevant. In this case, the method can reduce the loads on the backend data source 
     *  significantly.
     *  </para>
     *  <para>
     *  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
     *  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
     *  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
     *  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
     *  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
     *  </para>
     *  <para>
     *  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
     *  </para>
     *  <para>
     *  Note 2: A persisted entity (namely the one loaded
     *  from the data set) will be ignored in if none of its editable properties (set before system generation, see
     *  <see cref="Employee" />) is modified or its <see cref="Employee.IsEntityChanged" /> property is
     *  not set to <c>true</c>. 
     *  </para>
     *  <para>
     *  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
     *  proceeding to the next steps.
     *  </para>
     *  <para>
     *  Clients can set some of the member entities in { <see cref="Employee.ChangedEmployees" />, <see cref="Employee.ChangedEmployeeTerritorys" />, <see cref="Employee.ChangedOrders" /> } that an currently added or updated entity depends upon. These additional entities will be 
     *  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
     *  </para>
     *  <para>
     *  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
     *  </para>
     * </remarks>
     * <returns>
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=EnqueueNewOrUpdateEntities"
}
*/
    self.EnqueueNewOrUpdateEntities = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/EnqueueNewOrUpdateEntities',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx, 
                    set: input.set, 
                    entities: input.entities
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.EnqueueNewOrUpdateEntitiesResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  Delete a set of entities from the entity set, together with all their dependents, recursively. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">The current entity set.</param>
     * <param name="entities">The list of entities to be processed.</param>
     * <remarks>
     *  <para>
     *   Care should be taken when deleting an entire inter-dependent object sub-graph.
     *  </para>
     * </remarks>
     * <returns>
     *   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=DeleteEntities"
}
*/
    self.DeleteEntities = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/DeleteEntities',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx, 
                    set: input.set, 
                    entities: input.entities
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.DeleteEntitiesResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Get a block of page frames from the entity set "Employees" of the data source under specified filtering and sorting conditions. 
     * </summary>
     * <remarks>
     * The page size and the page block size is specified inside "set".
     * </remarks>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
     * <returns>
     *   <see cref="EmployeePageBlock" /> data model for entity set "Employees".
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=NextPageBlock"
}
*/
    self.NextPageBlock = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/NextPageBlock',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    set: input.set,
                    qexpr: input.qexpr,
                    prevlast: input.prevlast
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.NextPageBlockResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Load entities of a page from the entity set "Employees" of the data source under specified filtering and sorting conditions. 
     * </summary>
     * <remarks>
     * The page size is specified inside "set".
     * </remarks>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
     * <returns>
     *   Collection of <see cref="Employee" /> in set "Employees" for the current page defined by "prevlast".
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=GetPageItems"
}
*/
    self.GetPageItems = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/GetPageItems',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    set: input.set,
                    qexpr: input.qexpr,
                    prevlast: input.prevlast
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.GetPageItemsResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Employee'] !== 'undefined') {
                        resolve(propFilters['Employee'].many(data, false));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Count the number of entities inside entity set "Employees" of the data source under specified filtering condition. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <returns>
     *   The number of entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=QueryEntityCount"
}
*/
    self.QueryEntityCount = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/QueryEntityCount',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    set: input.set,
                    qexpr: input.qexpr
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.QueryEntityCountResult;
                    } else {
                        //json serializer turns 0 to null, recover here if it's the case
                        data = body === null ? 0 : body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Get the collection of entities of type <see cref="Employee" /> inside entity set "Employees" of the data source under specified filtering and sorting conditions. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <returns>
     *   The collection of entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=QueryDatabase"
}
*/
    self.QueryDatabase = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/QueryDatabase',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    set: input.set,
                    qexpr: input.qexpr
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.QueryDatabaseResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Employee'] !== 'undefined') {
                        resolve(propFilters['Employee'].many(data, false));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Get the collection of entities of type <see cref="Employee" /> inside entity set "Employees" from the data source under specified filtering, sorting and max number of returning entities conditions. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <param name="maxRecords">Max number of entities to return.</param>
     * <returns>
     *   The collection of entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=QueryDatabaseLimited"
}
*/
    self.QueryDatabaseLimited = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/QueryDatabaseLimited',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    set: input.set,
                    qexpr: input.qexpr,
                    maxRecords: input.maxRecords
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.QueryDatabaseLimitedResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Employee'] !== 'undefined') {
                        resolve(propFilters['Employee'].many(data, false));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Get the number of entities from the data source restricted by a set of specified foreign key values and under specified filtering, sorting conditions. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
    /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "Employees" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <returns>
     *   The number of entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=ConstraintQueryEntityCount"
}
*/
    self.ConstraintQueryEntityCount = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/ConstraintQueryEntityCount',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    set: input.set,
                    constraints: input.constraints,
                    qexpr: input.qexpr
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.ConstraintQueryEntityCountResult;
                    } else {
                        //json serializer turns 0 to null, recover here if it's the case
                        data = body === null ? 0 : body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Given a set of foreign key constraints, find the ones that has non zero corresponding entities. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
    /// <param name="cnstSets">A collection of sets of foreign key wrapper pointing to primary keys of the sets that "Employees" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <returns>
     *   A set of constraint pointer that has non-zero corresponding entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=ConstraintsFindMatches"
}
*/
    self.ConstraintsFindMatches = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/ConstraintsFindMatches',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    set: input.set,
                    cnstSets: input.cnstSets,
                    qexpr: input.qexpr
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.ConstraintsFindMatchesResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Get the collection of entities of type <see cref="Employee" /> inside entity set "Employees" from the data source restricted by a set of specified foreign key values and under specified filtering, sorting conditions. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
    /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "Employees" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <returns>
     *   The collection of entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=ConstraintQuery"
}
*/
    self.ConstraintQuery = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/ConstraintQuery',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    set: input.set,
                    constraints: input.constraints,
                    qexpr: input.qexpr
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.ConstraintQueryResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Employee'] !== 'undefined') {
                        resolve(propFilters['Employee'].many(data, false));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Get the collection of entities of type <see cref="Employee" /> inside entity set "Employees" of the data source restricted by a set of specified foreign key values and under specified filtering, sorting and max number of returning entities conditions. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="set">Set information.</param>
    /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "Employees" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
     * <param name="qexpr">Tokenized querying and sorting expression.</param>
     * <param name="maxRecords">Max number of entities to return.</param>
     * <returns>
     *   The collection of entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=ConstraintQueryLimited"
}
*/
    self.ConstraintQueryLimited = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/ConstraintQueryLimited',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    set: input.set,
                    constraints: input.constraints,
                    qexpr: input.qexpr,
                    maxRecords: input.maxRecords
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.ConstraintQueryLimitedResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Employee'] !== 'undefined') {
                        resolve(propFilters['Employee'].many(data, false));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Load the entity "UpperRef" of type <see cref="Employee" /> that the entity depend upon. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="entity">The entity.</param>
     * <remarks>
     * If the corresponding foreign key is nullable, the returned entity can be null.
     * </remarks>
     * <returns>
     *   An entity of type <see cref="Employee" /> or null.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=MaterializeUpperRef"
}
*/
    self.MaterializeUpperRef = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/MaterializeUpperRef',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    entity: input.entity
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.MaterializeUpperRefResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Employee'] !== 'undefined') {
                        resolve(propFilters['Employee'].one(data, false));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Load the set of depending entities "Employees" of type <see cref="EmployeeSet" /> of the entity. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="entity">The entity.</param>
     * <remarks>
     *  The set returned is a filtered subset whose members are all depending on the entity.
     * </remarks>
     * <returns>
     *   An entity of type <see cref="EmployeeSet" />.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=MaterializeEmployees"
}
*/
    self.MaterializeEmployees = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/MaterializeEmployees',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    entity: input.entity
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.MaterializeEmployeesResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Load the collection of depending entities "AllEmployees" of type <see cref="IEnumerable{Employee}" /> (T = <see cref="Employee" />) of the entity. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="entity">The entity.</param>
     * <returns>
     *   An collecton of type <see cref="IEnumerable{Employee}" /> (T = <see cref="Employee" />).
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=MaterializeAllEmployees"
}
*/
    self.MaterializeAllEmployees = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/MaterializeAllEmployees',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    entity: input.entity
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.MaterializeAllEmployeesResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Employee'] !== 'undefined') {
                        resolve(propFilters['Employee'].many(data, false));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Load the set of depending entities "EmployeeTerritorys" of type <see cref="EmployeeTerritorySet" /> of the entity. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="entity">The entity.</param>
     * <remarks>
     *  The set returned is a filtered subset whose members are all depending on the entity.
     * </remarks>
     * <returns>
     *   An entity of type <see cref="EmployeeTerritorySet" />.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=MaterializeEmployeeTerritorys"
}
*/
    self.MaterializeEmployeeTerritorys = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/MaterializeEmployeeTerritorys',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    entity: input.entity
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.MaterializeEmployeeTerritorysResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Load the collection of depending entities "AllEmployeeTerritorys" of type <see cref="IEnumerable{EmployeeTerritory}" /> (T = <see cref="EmployeeTerritory" />) of the entity. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="entity">The entity.</param>
     * <returns>
     *   An collecton of type <see cref="IEnumerable{EmployeeTerritory}" /> (T = <see cref="EmployeeTerritory" />).
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=MaterializeAllEmployeeTerritorys"
}
*/
    self.MaterializeAllEmployeeTerritorys = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/MaterializeAllEmployeeTerritorys',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    entity: input.entity
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.MaterializeAllEmployeeTerritorysResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['EmployeeTerritory'] !== 'undefined') {
                        resolve(propFilters['EmployeeTerritory'].many(data, false));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Load the set of indirectly depending entities "EmployeeTerritory" of type <see cref="TerritorySet" /> of an entity. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="entity">The entity.</param>
     * <remarks>
     *  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
     *  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
     * </remarks>
     * <returns>
     *   An entity of type <see cref="TerritorySet" />.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=MaterializeTerritories"
}
*/
    self.MaterializeTerritories = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/MaterializeTerritories',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    entity: input.entity
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.MaterializeTerritoriesResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Load the collection of indirectly depending entities "AllTerritories" of type <see cref="IEnumerable{Territory}" /> (T = <see cref="Territory" />) of the entity. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="entity">The entity.</param>
     * <remarks>
     *  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
     *  many to many relationship.
     * </remarks>
     * <returns>
     *   An entity of type <see cref="IEnumerable{Territory}" /> (T = <see cref="Territory" />).
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=MaterializeAllTerritories"
}
*/
    self.MaterializeAllTerritories = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/MaterializeAllTerritories',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    entity: input.entity
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.MaterializeAllTerritoriesResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Territory'] !== 'undefined') {
                        resolve(propFilters['Territory'].many(data, false));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Load the set of depending entities "Orders" of type <see cref="OrderSet" /> of the entity. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="entity">The entity.</param>
     * <remarks>
     *  The set returned is a filtered subset whose members are all depending on the entity.
     * </remarks>
     * <returns>
     *   An entity of type <see cref="OrderSet" />.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=MaterializeOrders"
}
*/
    self.MaterializeOrders = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/MaterializeOrders',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    entity: input.entity
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.MaterializeOrdersResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   Load the collection of depending entities "AllOrders" of type <see cref="IEnumerable{Order}" /> (T = <see cref="Order" />) of the entity. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="entity">The entity.</param>
     * <returns>
     *   An collecton of type <see cref="IEnumerable{Order}" /> (T = <see cref="Order" />).
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=MaterializeAllOrders"
}
*/
    self.MaterializeAllOrders = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/MaterializeAllOrders',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    entity: input.entity
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.MaterializeAllOrdersResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Order'] !== 'undefined') {
                        resolve(propFilters['Order'].many(data, false));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  Load an entity from the entity set having specified primary key(s): { <see cref="Employee.EmployeeID" /> }. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
    /// <param name="_EmployeeID">Primary key <see cref="Employee.EmployeeID" />.</param>
     * <returns>
     *   Null or the entity found.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=LoadEntityByKey"
}
*/
    self.LoadEntityByKey = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/LoadEntityByKey',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    _EmployeeID: input._EmployeeID || input.EmployeeID
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.LoadEntityByKeyResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Employee'] !== 'undefined') {
                        resolve(propFilters['Employee'].one(data, false));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="Employee.EmployeeID" /> }. . It is designed to be called by clients other than .Net native ones.
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
    /// <param name="_EmployeeID">Primary key <see cref="Employee.EmployeeID" />.</param>
     * <param name="excludedSets">A list of sets to be excluded. </param>
     * <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
     * <remarks>
     * <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
     * However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
     * world and at the data view model level, these views can be represented using entity graphs.</para>
     * <para>This method is designed to load a selected sub entity graph recursively from the data source in one call to the service starting with a given entity (id).
     * It could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
     * <para>The selection is controlled by two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
     * <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
     * better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
     * if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
     * following other routes. </para>
     * <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
     * the entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also loads all 
     * elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
     * the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
     * <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
     * and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
     * <para>Note that a data service has intrinsic limits that do not allow transmitting an entity graph that is too large in one call, so one has to select which part
     * of the entire graph should be loaded in each call to the data service,</para>
     * <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
     * sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
     * these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
     * added after the graph is materialized on the clients side, if needed.</para>
     * </remarks>
     * <returns>
     *   Null or the entity graph found.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=LoadEntityGraphRecursJson"
}
*/
    self.LoadEntityGraphRecursJson = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/LoadEntityGraphRecursJson',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    _EmployeeID: input._EmployeeID || input.EmployeeID,
                    excludedSets: input.excludedSets,
                    futherDrillSets: input.futherDrillSets
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.LoadEntityGraphRecursJsonResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  Load a set entities from the entity set having specified intrinsic ids: { <see cref="Employee.FirstName" />, <see cref="Employee.LastName" />, <see cref="Employee.BirthDate" /> }. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
    /// <param name="_FirstName">Intrinsic id <see cref="Employee.FirstName" />.</param>
    /// <param name="_LastName">Intrinsic id <see cref="Employee.LastName" />.</param>
    /// <param name="_BirthDate">Intrinsic id <see cref="Employee.BirthDate" />.</param>
     * <remarks>
     *  <para>
     *   If the intrinsic identifiers are well chosen, the returned entity set should contain zero or one item. This could not be the case
     *   if the system is attached to an existing database whose data were entered without respecting the rules (namely those entities having the
     *   same set of intrinsic identifiers should appear only once inside the data source) imposed later by the
     *   system.
     *  </para>
     * </remarks>
     * <returns>
     *   The list of found entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=LoadEntityByNature"
}
*/
    self.LoadEntityByNature = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/LoadEntityByNature',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    _FirstName: input._FirstName || input.FirstName, 
                    _LastName: input._LastName || input.LastName, 
                    _BirthDate: input._BirthDate || input.BirthDate
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.LoadEntityByNatureResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Employee'] !== 'undefined') {
                        resolve(propFilters['Employee'].many(data, false));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  For a hierarchic data set, load a set root entities from the entity set. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <remarks>
     *  A root entity is one that have no dependency on other entities inside the same data set, or its foreign key <see cref="Employee.ReportsTo" /> = null.
     * </remarks>
     * <returns>
     *   A set of wrapped root entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=LoadEntitySetRoots"
}
*/
    self.LoadEntitySetRoots = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/LoadEntitySetRoots',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.LoadEntitySetRootsResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Employee'] !== 'undefined') {
                        resolve(propFilters['Employee'].many(data, true));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  For a hierarchic data set, load a wrapped parent node of a node from the entity set. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="node">The wrapped node under consideration.</param>
     * <remarks>
     * </remarks>
     * <returns>
     *   Null or a wrapped parent entity.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=LoadEntityParent"
}
*/
    self.LoadEntityParent = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/LoadEntityParent',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    node: input.node
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.LoadEntityParentResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Employee'] !== 'undefined') {
                        resolve(propFilters['Employee'].one(data, true));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  For a hierarchic data set, load a collection of wrapped child nodes of a node from the entity set. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="node">The wrapped node under consideration.</param>
     * <remarks>
     * </remarks>
     * <returns>
     *   A collection of wrapped child entities.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=LoadEntityChildren"
}
*/
    self.LoadEntityChildren = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/LoadEntityChildren',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    node: input.node
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.LoadEntityChildrenResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Employee'] !== 'undefined') {
                        resolve(propFilters['Employee'].many(data, true));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  For a hierarchic data set, load the entire tree of wrapped nodes from the entity set, starting from any member node. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="entity">The starting entity under consideration.</param>
     * <remarks>
     *  Loading a tree in one call to the database can increase the performance by reducing the number of calls to the data service.
     * </remarks>
     * <returns>
     *   The wrapped root entity of the tree.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=LoadEntityFullHierarchyRecurs"
}
*/
    self.LoadEntityFullHierarchyRecurs = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/LoadEntityFullHierarchyRecurs',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    entity: input.entity
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.LoadEntityFullHierarchyRecursResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Employee'] !== 'undefined') {
                        resolve(propFilters['Employee'].recurs(data, true));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *   For a hierarchic data set, load a sub-tree of wrapped nodes with maximum relative height and relative depth from the entity set starting from any member node. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="entity">The starting entity under consideration.</param>
     * <param name="uplev">Include parent nodes of the starting node, together with all the sibling trees under them, up to this value in relative height. If the value is -1, then all 
     *    of the parent nodes and sibling trees (if any) will be included,</param>
     * <param name="lowlev">Include child nodes of the starting node down to this value in relative depth. If the value is -1, then all of the child nodes will be included,</param>
     * <remarks>
     * For a large tree, this method can help the clients to load only a partial tree with limited hight and depth that is connected to the starting node.
     * Loading a partial tree in one call to the database can increase the performance by reducing the number of calls to the data service.
     * </remarks>
     * <returns>
     *   The wrapped root entity of the partial tree.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=LoadEntityHierarchyRecurs"
}
*/
    self.LoadEntityHierarchyRecurs = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/LoadEntityHierarchyRecurs',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    entity: input.entity,
                    uplev: input.uplev,
                    lowlev: input.lowlev
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.LoadEntityHierarchyRecursResult;
                    } else {
                        data = body;
                    }
                    if ((typeof opts.json.cntx.allProperties === 'undefined' || !opts.json.cntx.allProperties) && (config.disablePropertyFiltering === 'undefined' || !config.disablePropertyFiltering) && typeof propFilters['Employee'] !== 'undefined') {
                        resolve(propFilters['Employee'].recurs(data, true));
                    } else {
                        resolve(data);
                    }
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  Load the delay loaded property <see cref="Employee.Notes" />. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
    /// <param name="_EmployeeID">Primary key <see cref="Employee.EmployeeID" />.</param>
     * <remarks>
     * </remarks>
     * <returns>
     *   The value of the property.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=LoadEntityNotes"
}
*/
    self.LoadEntityNotes = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/LoadEntityNotes',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    _EmployeeID: input._EmployeeID || input.EmployeeID
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.LoadEntityNotesResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  Update the delay loaded property <see cref="Employee.Notes" />. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
    /// <param name="_EmployeeID">Primary key <see cref="Employee.EmployeeID" />.</param>
     * <param name="data">The updated value.</param>
     * <remarks>
     * </remarks>
     * <returns>
     *   The value of the property.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=UpdateEntityNotes"
}
*/
    self.UpdateEntityNotes = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/UpdateEntityNotes',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    _EmployeeID: input._EmployeeID || input.EmployeeID,
                    data: input.data
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.UpdateEntityNotesResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  Load the delay loaded property <see cref="Employee.Photo" />. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
    /// <param name="_EmployeeID">Primary key <see cref="Employee.EmployeeID" />.</param>
     * <remarks>
     * </remarks>
     * <returns>
     *   The value of the property.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=LoadEntityPhoto"
}
*/
    self.LoadEntityPhoto = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/LoadEntityPhoto',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    _EmployeeID: input._EmployeeID || input.EmployeeID
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.LoadEntityPhotoResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  Update the delay loaded property <see cref="Employee.Photo" />. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
    /// <param name="_EmployeeID">Primary key <see cref="Employee.EmployeeID" />.</param>
     * <param name="data">The updated value.</param>
     * <remarks>
     * </remarks>
     * <returns>
     *   The value of the property.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=UpdateEntityPhoto"
}
*/
    self.UpdateEntityPhoto = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/UpdateEntityPhoto',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    _EmployeeID: input._EmployeeID || input.EmployeeID,
                    data: input.data
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.UpdateEntityPhotoResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="sorters">Sorter expression tokens.</param>
     * <returns>
     *   A list of possible sort tokens.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=GetNextSorterOps"
}
*/
    self.GetNextSorterOps = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/GetNextSorterOps',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    sorters: input.sorters
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.GetNextSorterOpsResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };

    /**
     * <summary>
     *  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. 
     * </summary>
     * <param name="cntx">Authenticated caller context object. If cannot be null.</param>
     * <param name="qexpr">The current query expression.</param>
     * <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
     * <returns>
     *   A list of possible filter tokens.
     * </returns>
     */

/* input parameter schema reference template
{
    "$schema": "http://localhost:11333/sets/EmployeeServiceInputParams?db=Northwind&subdoc=GetNextFilterOps"
}
*/
    self.GetNextFilterOps = function (input) {
        var __promise = new Q.Promise(function (resolve, reject, notify) {
            var opts = {
                url: self.baseUrl + '/GetNextFilterOps',
                method: 'POST',
                json: {
                    cntx: typeof input.cntx === 'undefined' || !input.cntx ? cntx : input.cntx,
                    qexpr: input.qexpr,
                    tkstr: input.tkstr
                }
            };
            req(opts, function (error, response, body) {
                if (!error && response.statusCode === 200) {
                    var data; 
                    if (typeof config.inProcessDatabase.wcfBackendService === 'undefined' || config.inProcessDatabase.wcfBackendService) {
                        data = body.GetNextFilterOpsResult;
                    } else {
                        data = body;
                    }
                    resolve(data);
                } else {
                    if (response)
                        reject({ err: error, httpCode: response.statusCode, msg: body });
                    else
                        reject({ err: error, httpCode: -1 });
                }
            });
        });
        return __promise;
    };
};

module.exports = api;
